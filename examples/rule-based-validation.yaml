# Example configuration demonstrating rule-based validation
# This shows how to use programmatic validation rules instead of AI analysis
# for fast, cheap validation checks

rule_definitions:
  # Example 1: File existence check
  claude_doc_missing:
    description: "Project lacks required CLAUDE.md documentation"
    detection_prompt: "Not used for programmatic rules"
    analysis_method: programmatic
    scope: project_level
    context: "CLAUDE.md provides essential AI agent context"
    requires_project_context: true
    validation_rules:
      scope: project_level
      document_bundle:
        bundle_type: configuration
        file_patterns: ["CLAUDE.md"]
        bundle_strategy: collection
      rules:
        - rule_type: file_exists
          description: "CLAUDE.md must exist in project root"
          file_path: "CLAUDE.md"
          failure_message: "CLAUDE.md file not found in project root"
          expected_behavior: "CLAUDE.md should exist with AI agent instructions and context"

  # Example 2: Regex content check
  skill_missing_prerequisites:
    description: "Skills missing required Prerequisites section"
    detection_prompt: "Not used for programmatic rules"
    analysis_method: programmatic
    scope: document_level
    context: "Prerequisites help AI understand dependencies before executing skills"
    requires_project_context: true
    validation_rules:
      scope: document_level
      document_bundle:
        bundle_type: skill
        file_patterns: [".claude/skills/*/SKILL.md"]
        bundle_strategy: individual
      rules:
        - rule_type: regex_match
          description: "SKILL.md must have Prerequisites section"
          file_path: "*/SKILL.md"
          pattern: "^##\\s+Prerequisites"
          flags: 8  # re.MULTILINE (8)
          failure_message: "SKILL.md missing '## Prerequisites' section"
          expected_behavior: "Each SKILL.md should document prerequisites for AI to check before execution"

  # Example 3: File count constraint
  too_many_commands:
    description: "Project has excessive command files"
    detection_prompt: "Not used for programmatic rules"
    analysis_method: programmatic
    scope: project_level
    context: "Too many commands overwhelm users and make discovery difficult"
    requires_project_context: true
    validation_rules:
      scope: project_level
      document_bundle:
        bundle_type: command
        file_patterns: [".claude/commands/*.md"]
        bundle_strategy: collection
      rules:
        - rule_type: file_count
          description: "Reasonable command count (max 20)"
          file_path: ".claude/commands/*.md"
          max_count: 20
          failure_message: "Too many command files (complexity creep detected)"
          expected_behavior: "Consolidate to <= 20 commands for better maintainability and discoverability"

  # Example 4: Multiple validation rules
  readme_requirements:
    description: "README missing required sections"
    detection_prompt: "Not used for programmatic rules"
    analysis_method: programmatic
    scope: project_level
    context: "README should have standard sections for documentation quality"
    requires_project_context: true
    validation_rules:
      scope: project_level
      document_bundle:
        bundle_type: documentation
        file_patterns: ["README.md"]
        bundle_strategy: collection
      rules:
        - rule_type: regex_match
          description: "README must have Installation section"
          pattern: "^##\\s+Installation"
          flags: 8  # re.MULTILINE
          failure_message: "README.md missing '## Installation' section"
          expected_behavior: "README should document how to install and set up the project"

        - rule_type: regex_match
          description: "README must have Usage section"
          pattern: "^##\\s+Usage"
          flags: 8  # re.MULTILINE
          failure_message: "README.md missing '## Usage' section"
          expected_behavior: "README should document how to use the project"

  # Example 5: Inverted logic - file should NOT exist
  deprecated_config_exists:
    description: "Deprecated configuration file still present"
    detection_prompt: "Not used for programmatic rules"
    analysis_method: programmatic
    scope: project_level
    context: "Old config format should be migrated to new format"
    requires_project_context: true
    validation_rules:
      scope: project_level
      document_bundle:
        bundle_type: configuration
        file_patterns: [".drift.yml"]  # Old format
        bundle_strategy: collection
      rules:
        - rule_type: file_not_exists
          description: "Deprecated .drift.yml should not exist"
          file_path: ".drift.yml"
          failure_message: "Deprecated .drift.yml configuration file found"
          expected_behavior: "Configuration should use new drift.yaml format instead"

# Benefits of rule-based validation:
# 1. **Performance**: No LLM calls = instant validation
# 2. **Cost**: Zero AI inference costs for simple checks
# 3. **Deterministic**: Same input always produces same result
# 4. **Offline**: Works without API connectivity
# 5. **Composable**: Combine multiple rules in single learning type
#
# Use programmatic validation for:
# - File existence/absence checks
# - Required content patterns (headers, sections, keywords)
# - File count/size constraints
# - Cross-file consistency checks (in future)
#
# Continue using AI analysis for:
# - Nuanced quality assessment
# - Context-dependent evaluation
# - Complex pattern detection
# - Natural language understanding
